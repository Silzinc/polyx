use crate::{
	consts::{SIGNIF_FIGS, TOL},
	traits::Primitive,
	Polynomial,
};
use num::complex::Complex;
use num_traits::ToPrimitive;
use std::fmt;

fn to_complexf64<T>(c: Complex<T>) -> Option<Complex<f64>>
	where T: Clone + ToPrimitive
{
	Some(Complex::new(c.re.to_f64()?, c.im.to_f64()?))
}

fn pretty_float(x: f64) -> String
{
	// Gives string representing x with n + 1 significant figures
	if x.abs() < TOL {
		return "0".to_string();
	}
	if x < 0. {
		return format!("-{}", pretty_float(-x));
	}
	let r = x.log10().floor() as i32;
	let d = r - SIGNIF_FIGS as i32;
	let power_ten = 10f64.powi(d);
	let rounded: i64 = (x / power_ten).round() as i64;
	if d == 0 {
		format!("{}", rounded)
	} else if r.abs() < SIGNIF_FIGS as i32 {
		if d > 0 {
			let mut result: String = rounded.to_string();
			for _ in 0..d {
				result.push('0');
			}
			result
		} else {
			let mut result: String = rounded.to_string();
			let point_index = result.len() - (-d) as usize;
			if point_index == 0 {
				"0.".to_string() + &result
			} else {
				result.insert(point_index, '.');
				result
			}
		}
	} else {
		format!("{0:10.1$}*10^{{ {2} }}", rounded as f64, SIGNIF_FIGS, power_ten.log10().round())
	}
}

fn pretty_term_complex(x: Complex<f64>, degree: usize) -> String
{
	// Gives string representing a term of degree `degree` of a polynomial with
	// complex coefficient x
	let real_literal = pretty_float(x.re.abs());
	let imag_literal = pretty_float(x.im.abs());

	if x.norm() < TOL {
		return "".to_string();
	}
	let xterm = if degree == 1 {
		"\\ X".to_string()
	} else {
		format!("\\ X^{{{}}}", degree)
	};

	let real_with_foreop = if x.re.abs() < TOL {
		"".to_string()
	} else if x.re > 0. {
		format!("+{}", real_literal)
	} else {
		format!("-{}", real_literal)
	};
	let imag_with_foreop = if x.im.abs() < TOL {
		"".to_string()
	} else if x.im > 0. {
		format!("+{}i", imag_literal)
	} else {
		format!("-{}i", imag_literal)
	};

	if degree == 0 {
		format!("{}{}", real_with_foreop, imag_with_foreop)
	} else if x.im.abs() < TOL {
		format!("{}{}", real_with_foreop, xterm)
	} else if x.re.abs() < TOL {
		format!("{}{}", imag_with_foreop, xterm)
	} else if x.re < 0. {
		if x.im < 0. {
			format!("-({}+{}i){}", real_literal, imag_literal, xterm)
		} else {
			format!("+({}{}){}", real_with_foreop, imag_with_foreop, xterm)
		}
	} else {
		format!("+({}{}){}", real_literal, imag_with_foreop, xterm)
	}
}

fn pretty_term_real(x: f64, degree: usize) -> String { pretty_term_complex(Complex::from(x), degree) }

impl<T> Polynomial<T> where T: Primitive
{
	/// Gives a LaTeX code to print the polynomial as long as the coefficients can
	/// be turned into f64 Only the first SIGNIF_FIGS + 1 significant figures are
	/// printed Only the coefficients with absolute value greater than TOL are
	/// printed.
	///
	/// ```rust
	/// use polyx::*;
	/// let p = polynomial![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
	/// println!("{}", p.to_latex());
	/// ```

	pub fn to_latex(&self) -> String
	{
		let mut length = self.0.len();
		while length > 0 && self[length - 1].to_f64().unwrap().abs() < TOL {
			length -= 1;
		}
		if length == 0 {
			return "0".to_string();
		}
		let mut result_str_vec = Vec::with_capacity(length + 1);
		for index in (0..length).rev() {
			let c: f64 = self[index].to_f64().unwrap();
			result_str_vec.push(pretty_term_real(c, index));
		}
		if result_str_vec[0].starts_with('+') {
			result_str_vec[0].remove(0);
		}
		// Replaces ugly * generated by pretty_float by a more LaTeX-friendly \cdot
		result_str_vec.join("")
		              .chars()
		              .map(|c| if c == '*' { "\\cdot".to_string() } else { c.to_string() })
		              .collect()
	}
}

impl<T> Polynomial<Complex<T>> where T: Primitive
{
	pub fn to_latex(&self) -> String
	{
		let mut length = self.0.len();
		while length > 0 && to_complexf64(self[length - 1].clone()).unwrap().norm() < TOL {
			length -= 1;
		}
		if length == 0 {
			return "0".to_string();
		}
		let mut result_str_vec = Vec::with_capacity(length + 1);
		for index in (0..length).rev() {
			let c: Complex<f64> = to_complexf64(self[index].clone()).unwrap();
			result_str_vec.push(pretty_term_complex(c, index));
		}
		if result_str_vec[0].starts_with('+') {
			result_str_vec[0].remove(0);
		}
		// Replaces ugly * generated by pretty_float by a more LaTeX-friendly \cdot
		result_str_vec.join("")
		              .chars()
		              .map(|c| if c == '*' { "\\cdot".to_string() } else { c.to_string() })
		              .collect()
	}
}

impl<T> fmt::Display for Polynomial<T> where T: Primitive
{
	/// Allows to display the polynomial in a fancy way
	/// Example:
	/// ```rust
	/// use polyx::*;
	/// let p = polynomial![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
	/// println!("{}", p);
	/// ```
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
	{
		if self.is_empty() {
			return write!(f, "Polynomial(-Inf)");
		}
		let degree = self.degree();
		if degree == 0 {
			return write!(f, "{}", format!("Polynomial(0)\n {:10.3e}", self[0].to_f64().unwrap()));
		}

		let mut result_str_vec = Vec::with_capacity(degree + 2);

		result_str_vec.push(format!("Polynomial({degree})"));

		let c: f64 = self[degree].to_f64().unwrap();
		if c > TOL {
			result_str_vec.push(format!(" {:10.3e} X^{degree}", c));
		} else if c < -TOL {
			result_str_vec.push(format!("-{:10.3e} X^{degree}", -c));
		}

		for index in (1..degree).rev() {
			let c: f64 = self[index].to_f64().unwrap();
			if c > TOL {
				result_str_vec.push(format!("+{:10.3e} X^{index}", c));
			} else if c < -TOL {
				result_str_vec.push(format!("-{:10.3e} X^{index}", -c));
			}
		}

		let c: f64 = self[0].to_f64().unwrap();
		if c > TOL {
			result_str_vec.push(format!("+{:10.3e}", c));
		} else if c < -TOL {
			result_str_vec.push(format!("-{:10.3e}", -c));
		}

		write!(f, "{}", result_str_vec.join("\n"))
	}
}

impl<T> fmt::Display for Polynomial<Complex<T>> where T: Primitive
{
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
	{
		if self.is_empty() {
			return write!(f, "Polynomial(-Inf)");
		}
		let degree = self.degree();
		if degree == 0 {
			return write!(
			              f,
			              "{}",
			              format!("Polynomial(0)\n {:10.3e}", to_complexf64(self[0].clone()).unwrap())
			);
		}

		let mut result_str_vec = Vec::with_capacity(degree + 2);

		result_str_vec.push(format!("Polynomial({degree})"));

		let c: Complex<f64> = to_complexf64(self[degree].clone()).unwrap();
		if c.norm() > TOL {
			result_str_vec.push(format!(" ({:10.3e}) X^{degree}", c));
		}

		for index in (1..degree).rev() {
			let c: Complex<f64> = to_complexf64(self[index].clone()).unwrap();
			if c.norm() > TOL {
				result_str_vec.push(format!("+({:10.3e}) X^{index}", c));
			}
		}

		let c: Complex<f64> = to_complexf64(self[0].clone()).unwrap();
		if c.norm() > TOL {
			result_str_vec.push(format!("+{:10.3e}", c));
		}

		write!(f, "{}", result_str_vec.join("\n"))
	}
}
